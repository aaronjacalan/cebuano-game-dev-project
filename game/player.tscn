[gd_scene load_steps=12 format=3 uid="uid://o7gchgjqr1i6"]

[ext_resource type="PackedScene" uid="uid://bklxl232veydp" path="res://assets/player/first_person_arm.tscn" id="1_dadds"]
[ext_resource type="Shader" uid="uid://bt1lbo5yomj25" path="res://game/shaders/retro_camera.gdshader" id="2_w5y0b"]
[ext_resource type="Shader" uid="uid://di14027j7obwb" path="res://game/shaders/VHS.gdshader" id="3_du4nq"]
[ext_resource type="Script" path="res://game/player_interact.gd" id="4_p0vpi"]
[ext_resource type="Shader" uid="uid://ddx2gqb8873he" path="res://game/playershaders/thirdeyeshader.gdshader" id="5_d631c"]

[sub_resource type="GDScript" id="GDScript_sh265"]
script/source = "extends CharacterBody3D

# Simplified Godot 4.5 first-person controller with stair snapping
# - plays \"Combat_idle_start\" once, then blends into \"Combat_idle\"
# - basic movement, gravity, mouse look, and head-bob
# - uses \"punch\" input action for punching
# - smooth stair traversal (up and down)

# Movement
const SPEED: float = 6.5
const ACCEL: float = 20.0
const FRICTION: float = 20.0
const AIR_FRICTION: float = 2.0
const JUMP_VELOCITY: float = 5.0


# Look
const MOUSE_SENS: float = 0.0005
const MAX_PITCH: float = deg_to_rad(89.0)

# Head bob
const BOB_FREQ: float = 2.0
const BOB_AMP: float = 0.08
const BOB_LERP: float = 2.0

# Stairs
const MAX_STEP_HEIGHT: float = 0.5
@onready var overlay = %ThirdEyeShader
var overlay_visible := false
@onready var head: Node3D = $Head
@onready var camera: Camera3D = $Head/Camera3D
@onready var anim: AnimationPlayer = $PSX_First_Person_Arms/AnimationPlayer

# Raycasts for stair detection
@onready var stairs_below_raycast: RayCast3D = $StairsBelowRayCast3D
@onready var stairs_ahead_raycast: RayCast3D = $StairsAheadRayCast3D

var bob_time: float = 0.0
var cam_rest_y: float = 0.0
var idle_ready: bool = false
var is_attacking: bool = false

# Stair tracking
var _snapped_to_stairs_last_frame: bool = false
var _last_frame_was_on_floor: int = -999999


func _ready() -> void:
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
	
	# Setup raycasts if they don't exist
	_setup_stair_raycasts()
	
	# Wait a frame so camera exists and transforms are valid
	await get_tree().process_frame
	
	if camera:
		cam_rest_y = camera.position.y
	
	# Play startup idle, then connect to animation_finished
	if anim:
		if not anim.animation_finished.is_connected(_on_animation_finished):
			anim.animation_finished.connect(_on_animation_finished)
		anim.play(\"Combat_idle_start\")


func _setup_stair_raycasts() -> void:
	# Create raycasts if they don't exist
	if not stairs_below_raycast:
		stairs_below_raycast = RayCast3D.new()
		stairs_below_raycast.name = \"StairsBelowRayCast3D\"
		stairs_below_raycast.target_position = Vector3(0, -MAX_STEP_HEIGHT, 0)
		stairs_below_raycast.enabled = true
		stairs_below_raycast.collide_with_areas = false
		add_child(stairs_below_raycast)
	
	if not stairs_ahead_raycast:
		stairs_ahead_raycast = RayCast3D.new()
		stairs_ahead_raycast.name = \"StairsAheadRayCast3D\"
		stairs_ahead_raycast.target_position = Vector3(0, -MAX_STEP_HEIGHT, 0)
		stairs_ahead_raycast.enabled = true
		stairs_ahead_raycast.collide_with_areas = false
		add_child(stairs_ahead_raycast)


func _on_animation_finished(anim_name: String) -> void:
	if anim_name == \"Combat_idle_start\":
		if anim:
			anim.play(\"Combat_idle\")
		idle_ready = true
	elif anim_name == \"Combat_punch_left\":
		is_attacking = false
		if anim:
			anim.play(\"Combat_idle\")


func _input(event: InputEvent) -> void:
	# Mouse look
	if event is InputEventMouseMotion:
		rotate_y(-event.relative.x * MOUSE_SENS)
		
		if head:
			var new_pitch: float = head.rotation.x - event.relative.y * MOUSE_SENS
			head.rotation.x = clamp(new_pitch, -MAX_PITCH, MAX_PITCH)
	
	if event.is_action_pressed(\"punch\"):
		_try_punch()
	if event.is_action_pressed(\"move_third_eye\"):
		overlay_visible = !overlay_visible
		if overlay: 
			overlay.visible = overlay_visible

func _try_punch() -> void:
	if not is_attacking and idle_ready and anim:
		is_attacking = true
		anim.play(\"Combat_punch_left\")


func _physics_process(delta: float) -> void:
	# Track floor state for stairs
	if is_on_floor():
		_last_frame_was_on_floor = Engine.get_physics_frames()
	
	# Apply gravity
	if not is_on_floor():
		velocity += get_gravity() * delta
	
	# Get movement input
	var input_dir: Vector2 = Input.get_vector(\"move_left\", \"move_right\", \"move_forward\", \"move_backward\")
	
	# Convert to 3D direction relative to character's rotation
	var direction: Vector3 = Vector3.ZERO
	if input_dir.length() > 0.0:
		var local_direction: Vector3 = Vector3(input_dir.x, 0.0, input_dir.y)
		direction = (transform.basis * local_direction).normalized()
	
	# Select appropriate friction
	var current_friction: float = FRICTION if is_on_floor() else AIR_FRICTION
	
	# Apply acceleration or friction
	if direction.length() > 0.0:
		velocity.x = move_toward(velocity.x, direction.x * SPEED, ACCEL * delta)
		velocity.z = move_toward(velocity.z, direction.z * SPEED, ACCEL * delta)
	else:
		velocity.x = move_toward(velocity.x, 0.0, current_friction * delta)
		velocity.z = move_toward(velocity.z, 0.0, current_friction * delta)
	
	# Check for stair step up before moving
	if not _snap_up_stairs_check(delta, direction):
		# Normal movement if not stepping up stairs
		move_and_slide()
		# Check for stair snap down after moving
		_snap_down_to_stairs_check()
	
	# Apply head bob (disable during attack)
	if not is_attacking:
		_apply_head_bob(delta, direction)


func _snap_down_to_stairs_check() -> void:
	if not stairs_below_raycast:
		return
	
	var did_snap: bool = false
	stairs_below_raycast.force_raycast_update()
	
	var floor_below: bool = stairs_below_raycast.is_colliding() and not _is_surface_too_steep(stairs_below_raycast.get_collision_normal())
	var was_on_floor_last_frame: bool = Engine.get_physics_frames() == _last_frame_was_on_floor
	
	if not is_on_floor() and velocity.y <= 0 and (was_on_floor_last_frame or _snapped_to_stairs_last_frame) and floor_below:
		# Use PhysicsTestMotionParameters3D instead of creating KinematicCollision3D
		var params := PhysicsTestMotionParameters3D.new()
		params.from = global_transform
		params.motion = Vector3(0, -MAX_STEP_HEIGHT, 0)
		
		var result := PhysicsTestMotionResult3D.new()
		if PhysicsServer3D.body_test_motion(get_rid(), params, result):
			var translate_y: float = result.get_travel().y
			position.y += translate_y
			apply_floor_snap()
			did_snap = true
	
	_snapped_to_stairs_last_frame = did_snap


func _snap_up_stairs_check(delta: float, direction: Vector3) -> bool:
	if not stairs_ahead_raycast:
		return false
	
	if not is_on_floor() and not _snapped_to_stairs_last_frame:
		return false
	
	# Don't snap if not moving
	if direction.length() == 0.0:
		return false
	
	var expected_move_motion: Vector3 = velocity * Vector3(1, 0, 1) * delta
	var step_pos_with_clearance: Transform3D = global_transform.translated(expected_move_motion + Vector3(0, MAX_STEP_HEIGHT * 2, 0))
	
	# Use PhysicsTestMotionParameters3D for better performance
	var params := PhysicsTestMotionParameters3D.new()
	params.from = step_pos_with_clearance
	params.motion = Vector3(0, -MAX_STEP_HEIGHT * 2, 0)
	
	var result := PhysicsTestMotionResult3D.new()
	if PhysicsServer3D.body_test_motion(get_rid(), params, result):
		var collider: Object = result.get_collider()
		if collider and (collider is StaticBody3D or collider is CSGShape3D):
			var step_height: float = ((step_pos_with_clearance.origin + result.get_travel()) - global_position).y
			
			if step_height > MAX_STEP_HEIGHT or step_height <= 0.01:
				return false
			if (result.get_collision_point(0) - global_position).y > MAX_STEP_HEIGHT:
				return false
			
			# Check ahead
			stairs_ahead_raycast.global_position = result.get_collision_point(0) + Vector3(0, MAX_STEP_HEIGHT, 0) + expected_move_motion.normalized() * 0.1
			stairs_ahead_raycast.force_raycast_update()
			
			if stairs_ahead_raycast.is_colliding() and not _is_surface_too_steep(stairs_ahead_raycast.get_collision_normal()):
				global_position = step_pos_with_clearance.origin + result.get_travel()
				apply_floor_snap()
				_snapped_to_stairs_last_frame = true
				return true
	
	return false


func _is_surface_too_steep(normal: Vector3) -> bool:
	return normal.angle_to(Vector3.UP) > floor_max_angle


func _apply_head_bob(delta: float, dir: Vector3) -> void:
	if not camera:
		return
	
	if cam_rest_y == 0.0:
		cam_rest_y = camera.position.y
	
	# Apply bobbing when moving on ground
	if is_on_floor() and dir.length() > 0.0:
		bob_time += delta * BOB_FREQ
		var target_y: float = cam_rest_y + sin(bob_time * TAU) * BOB_AMP
		camera.position.y = lerp(camera.position.y, target_y, BOB_LERP * delta)
	else:
		bob_time = 0.0
		camera.position.y = lerp(camera.position.y, cam_rest_y, BOB_LERP * delta)
		
		
func third_eye():
	pass


func _unhandled_input(event: InputEvent) -> void:
	if event.is_action_pressed(\"ui_cancel\"):
		if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
			Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		else:
			Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
"

[sub_resource type="CapsuleMesh" id="CapsuleMesh_sh265"]
radius = 0.3
height = 2.5

[sub_resource type="ConvexPolygonShape3D" id="ConvexPolygonShape3D_dadds"]
points = PackedVector3Array(0.31495512, -0.99171406, 0.15625602, -0.20072375, 1.0710014, 0.2753114, -0.20072375, 1.031482, -0.2800733, 0.19596188, -1.0710014, -0.2800733, -0.20072375, -1.0710014, 0.2753114, 0.15625602, 0.99171406, 0.31495512, -0.319717, 1.031482, -0.1213742, 0.19596188, 1.0710014, -0.2800733, -0.1213742, -1.031482, -0.319717, 0.15625602, -0.99171406, 0.31495512, 0.31495512, 0.99171406, 0.15625602, 0.2753114, -1.0710014, -0.20072375, -0.2800733, -1.0710014, 0.19596188, 0.07365631, 1.217311, 0.11173453, 0.073656335, -1.2173115, 0.11173457, -0.319717, -1.031482, -0.1213742, -0.2800733, 1.0710014, 0.19596188, 0.2753114, 1.0710014, -0.20072375, -0.0782358, -1.2143912, -0.11622269, -0.078235716, 1.2143898, -0.11622256, -0.1213742, 1.031482, -0.319717, -0.2800733, -1.031482, -0.20072375, -0.11632692, -1.2155031, 0.073543385, -0.11632681, 1.2155019, 0.0735433, 0.11162068, -1.2160966, -0.078342326, 0.111619934, 1.2160887, -0.07834183, -0.20072375, -1.031482, -0.2800733, -0.2800733, 1.031482, -0.20072375, 0.18435954, 1.1578844, 0.10965164, 0.18435414, -1.157851, 0.10964841, -0.19056365, -1.1668271, -0.07760685, -0.19056298, 1.1668229, -0.07760658)

[sub_resource type="ShaderMaterial" id="ShaderMaterial_du4nq"]
shader = ExtResource("2_w5y0b")
shader_parameter/aberration_strength = 3.0
shader_parameter/blur_strength = 2.0
shader_parameter/noise_strength = 0.048
shader_parameter/vignette_strength = 0.78
shader_parameter/scanline_strength = 0.016
shader_parameter/distortion_strength = 0.1
shader_parameter/ghost_strength = 0.12
shader_parameter/flicker_strength = 0.005

[sub_resource type="ShaderMaterial" id="ShaderMaterial_p0vpi"]
shader = ExtResource("3_du4nq")
shader_parameter/wiggle = 0.03
shader_parameter/wiggle_speed = 25.0
shader_parameter/smear = 1.0
shader_parameter/blur_samples = 15

[sub_resource type="ShaderMaterial" id="ShaderMaterial_4fto2"]
shader = ExtResource("5_d631c")
shader_parameter/brightness = 1.5
shader_parameter/contrast = 1.2
shader_parameter/vignette_strength = 0.8
shader_parameter/noise_strength = 0.15
shader_parameter/grain_size = 3.0

[node name="Player" type="CharacterBody3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.25, 0)
script = SubResource("GDScript_sh265")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("CapsuleMesh_sh265")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("ConvexPolygonShape3D_dadds")

[node name="PSX_First_Person_Arms" parent="." instance=ExtResource("1_dadds")]
transform = Transform3D(-1.5, 0, -2.2649371e-07, 0, 1.5, 0, 2.2649371e-07, 0, -1.5, 0, -1.8, 0)

[node name="Head" type="Node3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)

[node name="Camera3D" type="Camera3D" parent="Head"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.1, -0.2)

[node name="Spotlight" type="Node3D" parent="Head/Camera3D"]

[node name="SpotLight3D" type="SpotLight3D" parent="Head/Camera3D/Spotlight"]
light_color = Color(0.92941177, 0.8235294, 0.79607844, 1)
light_energy = 4.0
light_volumetric_fog_energy = 0.0
spot_range = 30.0
spot_attenuation = 1.15
spot_angle_attenuation = 1.1095695

[node name="Filters" type="CanvasLayer" parent="Head/Camera3D"]
visible = false

[node name="Post_Processing" type="ColorRect" parent="Head/Camera3D/Filters"]
material = SubResource("ShaderMaterial_du4nq")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackBufferCopy" type="BackBufferCopy" parent="Head/Camera3D/Filters"]
copy_mode = 2

[node name="VHS" type="ColorRect" parent="Head/Camera3D/Filters"]
material = SubResource("ShaderMaterial_p0vpi")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ThirdEye" type="CanvasLayer" parent="Head/Camera3D"]
visible = false

[node name="ThirdEyeShader" type="ColorRect" parent="Head/Camera3D/ThirdEye"]
unique_name_in_owner = true
material = SubResource("ShaderMaterial_4fto2")
offset_left = 1.0
offset_right = 3350.0
offset_bottom = 2134.0

[node name="RayCast3D" type="RayCast3D" parent="Head"]
transform = Transform3D(1.5, 0, 0, 0, -6.556708e-08, -1.5, 0, 1.5, -6.556708e-08, 0, 0, 0)
script = ExtResource("4_p0vpi")

[node name="StairsAheadRayCast3D" type="RayCast3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.6, -1)
target_position = Vector3(0, -0.65, 0)

[node name="StairsBelowRayCast3D" type="RayCast3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -1.25, 0)
